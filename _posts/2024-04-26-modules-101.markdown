---
layout: post
title:  "Valkey modules 101"
authors: 
  - dmitrypol
date: 2024-04-26 01:01:01 -0700
categories: modules
---

## What are Valkey modules?  

The idea of modules is to keep the core Valkey functionality lean and add extra features (such as new commands and data types) where needed.  Modules can be written in C or other languages that have C bindings.  In this article we will go through the process of building simple modules in C and Rust (using the Valkey Module Rust SDK).  This articles expects the audience to be at least somewhat familiar with C, Rust and Valkey.  

## Hello World module in C

If we clone [Valkey](https://github.com/valkey-io/valkey) repo we will find numerous examples in `src/modules`.  Let's create a new file `module1.c` in the same folder.  

```c
#include "../valkeymodule.h"

int hello(ValkeyModuleCtx *ctx, ValkeyModuleString **argv, int argc) {
    VALKEYMODULE_NOT_USED(argv);
    VALKEYMODULE_NOT_USED(argc);
    return ValkeyModule_ReplyWithSimpleString(ctx, "world1");
}

int ValkeyModule_OnLoad(ValkeyModuleCtx *ctx, ValkeyModuleString **argv, int argc) {
    VALKEYMODULE_NOT_USED(argv);
    VALKEYMODULE_NOT_USED(argc);
    if (ValkeyModule_Init(ctx,"module1",1,VALKEYMODULE_APIVER_1) 
        == VALKEYMODULE_ERR) return VALKEYMODULE_ERR;
    if (ValkeyModule_CreateCommand(ctx,"module1.hello", hello,"",0,0,0) 
        == VALKEYMODULE_ERR) return VALKEYMODULE_ERR;
    return VALKEYMODULE_OK;
}
```

All we are doing is initalizing `module1` and creating a command `hello` that returns `world1`.  Now we need to update `src/modules/Makefile`

```makefile
all: ... module1.so

module1.xo: ../valkeymodule.h

module1.so: module1.xo
	$(LD) -o $@ $^ $(SHOBJ_LDFLAGS) $(LIBS) -lc
```

Run `make` inside `src/modules` folder.  We will see numerous *.so and *.xo files created in `src/modules` including `module1.so`.  


## Hello World module in Rust

If we clone the [valkeymodule-rs](https://github.com/valkey-io/valkeymodule-rs) repo we will find `examples` folder with numerous .rs files.  The plan is to update the SDK to use variables like `ValkeyResult` and add it to [crates.io](https://crates.io/) but for now we will use it as is.  

Let's create `examples/module2.rs`

```rust
use redis_module::{redis_module, Context, RedisResult, RedisString, RedisValue};

fn hello(_ctx: &Context, _args: Vec<RedisString>) -> RedisResult {
    Ok(RedisValue::SimpleStringStatic("world2"))
}

redis_module! {
    name: "module2",
    version: 1,
    allocator: (redis_module::alloc::RedisAlloc, redis_module::alloc::RedisAlloc),
    data_types: [],
    commands: [
        ["module2.hello", hello, "", 0, 0, 0],
    ],
}
```

Rust syntax is a bit different than C but we are creating `module2` with command `hello` that returns `world2` string.  To accomplish that we are using [Rust macros](https://doc.rust-lang.org/book/ch19-06-macros.html) and passing it variables like `name` and `version`.  Some variables like `data_types` and `commands` are arrays and we can pass zero, one or many values.  Since we not using ctx or args we prefix them with `_` (Rust convention) instead of using `VALKEYMODULE_NOT_USED` as we did in C.  

Now we need to update `Cargo.toml` in the root folder.  Add this the bottom of the file:

```toml
[[example]]
name = "module2"
crate-type = ["cdylib"]
```

Run `cargo build --examples --no-default-features` in the root folder.  We will now see numerous files in `target/debug/examples` including `libmodule2.dylib` (on macOS).  It will produce *.so files on Linux and *.dll files on Windows.  Read [Rust docs](https://doc.rust-lang.org/reference/linkage.html) to understand more about `crate-type`.


## Run Valkey server with both modules

Go back into valkey repo folder and run make to compile the Valkey code.  Then add these lines to the bottom of `valkey.conf` file.

```
loadmodule path_to_valkey/src/modules/module1.so
loadmodule path_to_valkeymodule-rs/target/debug/examples/libmodule2.dylib
```

and run `src/valkey-server valkey.conf`.  You will see these messages in the log output.  

```
Module 'module1' loaded from path_to_valkey/src/modules/module1.so
...
Module 'module2' loaded from path_to_valkeymodule-rs/target/debug/examples/libmodule2.dylib
```

Then use `src/valkey-cli` to connect.  

```bash
src/valkey-cli -3
127.0.0.1:6379> module list
1) 1# "name" => "module2"
   2# "ver" => (integer) 1
   3# "path" => "path_to_valkeymodule-rs/target/debug/examples/libmodule2.dylib"
   4# "args" => (empty array)
2) 1# "name" => "module1"
   2# "ver" => (integer) 1
   3# "path" => "path_to_valkey/src/modules/module1.so"
   4# "args" => (empty array)
127.0.0.1:6379> module1.hello
world1
127.0.0.1:6379> module2.hello
world2
```

We can now run both modules side by side and if we modify either C or RS file, recompile the code and restart `valkey-server` we will get the new functionality.  Alternatively to specifying modules in .conf file we can use MODULE LOAD and UNLOAD from valkey-cli at runtime.  

Please stay tuned for more articles in the future as we explore the possibilities of Valkey modules and where using C or Rust makes sense.  

## Usefull links

* [Valkey repo](https://github.com/valkey-io/valkey)
* [Valkey Rust SDK](https://github.com/valkey-io/valkeymodule-rs)
* [Rust in VS Code](https://code.visualstudio.com/docs/languages/rust)
